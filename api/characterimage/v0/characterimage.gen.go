// Package characterimage provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package characterimage

import (
	"fmt"
	"net/http"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/labstack/echo/v4"
)

// Defines values for DynamicPartType.
const (
	LEFTARM  DynamicPartType = "LEFT_ARM"
	LEFTLEG  DynamicPartType = "LEFT_LEG"
	RIGHTARM DynamicPartType = "RIGHT_ARM"
	RIGHTLEG DynamicPartType = "RIGHT_LEG"
)

// Defines values for ExpressionType.
const (
	NEUTRAL ExpressionType = "NEUTRAL"
)

// Defines values for PropType.
const (
	RANGEDMELEE1H PropType = "RANGED_MELEE_1H"
	RANGEDMELEE2H PropType = "RANGED_MELEE_2H"
	WEAPONMELEE1H PropType = "WEAPON_MELEE_1H"
	WEAPONMELEE2H PropType = "WEAPON_MELEE_2H"
)

// Defines values for StaticPartType.
const (
	ACCESSORYHEAD StaticPartType = "ACCESSORY_HEAD"
	BODY          StaticPartType = "BODY"
	EYES          StaticPartType = "EYES"
	HAIR          StaticPartType = "HAIR"
	HEAD          StaticPartType = "HEAD"
)

// Animation defines model for Animation.
type Animation struct {
	AllowedProps *[]PropType `json:"allowedProps,omitempty"`
	DisplayName  *string     `json:"displayName,omitempty"`
}

// BodyItem defines model for BodyItem.
type BodyItem struct {
	DisplayName *string `json:"displayName,omitempty"`
}

// Coordinates defines model for Coordinates.
type Coordinates struct {
	True *int `json:"true,omitempty"`
	X    *int `json:"x,omitempty"`
}

// DynamicPartType defines model for DynamicPartType.
type DynamicPartType string

// ExpressionType defines model for ExpressionType.
type ExpressionType string

// Positioning defines model for Positioning.
type Positioning struct {
	Coordinates *Coordinates `json:"coordinates,omitempty"`
	Rotation    *int         `json:"rotation,omitempty"`
}

// PropType defines model for PropType.
type PropType string

// StaticPartType defines model for StaticPartType.
type StaticPartType string

// Animaton defines model for animaton.
type Animaton = Animation

// Body defines model for body.
type Body = BodyItem

// Dynamic defines model for dynamic.
type Dynamic struct {
	DisplayName *string          `json:"displayName,omitempty"`
	Image       *string          `json:"image,omitempty"`
	PartType    *DynamicPartType `json:"partType,omitempty"`
}

// DynamicMapping defines model for dynamicMapping.
type DynamicMapping struct {
	Image    *string          `json:"image,omitempty"`
	PartType *DynamicPartType `json:"partType,omitempty"`
}

// Frame defines model for frame.
type Frame struct {
	Expression       *ExpressionType `json:"expression,omitempty"`
	Image            *string         `json:"image,omitempty"`
	PartsPositioning *[]struct {
		PartType    *StaticPartType `json:"partType,omitempty"`
		Positioning *Positioning    `json:"positioning,omitempty"`
	} `json:"partsPositioning,omitempty"`
	PropPositioning *Positioning `json:"propPositioning,omitempty"`
}

// Prop defines model for prop.
type Prop struct {
	Anchor      *Coordinates `json:"anchor,omitempty"`
	DisplayName *string      `json:"displayName,omitempty"`
	Image       *string      `json:"image,omitempty"`
	PropType    *PropType    `json:"propType,omitempty"`
}

// Static defines model for static.
type Static struct {
	Anchor   *Coordinates    `json:"anchor,omitempty"`
	Image    *string         `json:"image,omitempty"`
	PartType *StaticPartType `json:"partType,omitempty"`
}

// AddBodyJSONRequestBody defines body for AddBody for application/json ContentType.
type AddBodyJSONRequestBody = Body

// AddAnimationJSONRequestBody defines body for AddAnimation for application/json ContentType.
type AddAnimationJSONRequestBody = Animaton

// AddAnimationFrameJSONRequestBody defines body for AddAnimationFrame for application/json ContentType.
type AddAnimationFrameJSONRequestBody Frame

// AddDynamicJSONRequestBody defines body for AddDynamic for application/json ContentType.
type AddDynamicJSONRequestBody Dynamic

// AddDynamicMappingJSONRequestBody defines body for AddDynamicMapping for application/json ContentType.
type AddDynamicMappingJSONRequestBody DynamicMapping

// AddStaticJSONRequestBody defines body for AddStatic for application/json ContentType.
type AddStaticJSONRequestBody Static

// AddPropJSONRequestBody defines body for AddProp for application/json ContentType.
type AddPropJSONRequestBody Prop

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /body)
	ListBodies(ctx echo.Context) error

	// (POST /body)
	AddBody(ctx echo.Context) error

	// (GET /body/{bodyID}/animation)
	ListAnimations(ctx echo.Context, bodyID string) error

	// (POST /body/{bodyID}/animation)
	AddAnimation(ctx echo.Context, bodyID string) error

	// (POST /body/{bodyID}/animation/{animationID}/frame)
	AddAnimationFrame(ctx echo.Context, bodyID string, animationID string) error

	// (GET /body/{bodyID}/dynamic)
	ListDyanmics(ctx echo.Context, bodyID string) error

	// (POST /body/{bodyID}/dynamic)
	AddDynamic(ctx echo.Context, bodyID string) error

	// (POST /body/{bodyID}/dynamicMapping)
	AddDynamicMapping(ctx echo.Context, bodyID string) error

	// (GET /body/{bodyID}/static)
	ListStatics(ctx echo.Context, bodyID string) error

	// (POST /body/{bodyID}/static)
	AddStatic(ctx echo.Context, bodyID string) error

	// (GET /prop)
	ListProps(ctx echo.Context) error

	// (POST /prop)
	AddProp(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListBodies converts echo context to params.
func (w *ServerInterfaceWrapper) ListBodies(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListBodies(ctx)
	return err
}

// AddBody converts echo context to params.
func (w *ServerInterfaceWrapper) AddBody(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddBody(ctx)
	return err
}

// ListAnimations converts echo context to params.
func (w *ServerInterfaceWrapper) ListAnimations(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bodyID" -------------
	var bodyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "bodyID", runtime.ParamLocationPath, ctx.Param("bodyID"), &bodyID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bodyID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListAnimations(ctx, bodyID)
	return err
}

// AddAnimation converts echo context to params.
func (w *ServerInterfaceWrapper) AddAnimation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bodyID" -------------
	var bodyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "bodyID", runtime.ParamLocationPath, ctx.Param("bodyID"), &bodyID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bodyID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddAnimation(ctx, bodyID)
	return err
}

// AddAnimationFrame converts echo context to params.
func (w *ServerInterfaceWrapper) AddAnimationFrame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bodyID" -------------
	var bodyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "bodyID", runtime.ParamLocationPath, ctx.Param("bodyID"), &bodyID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bodyID: %s", err))
	}

	// ------------- Path parameter "animationID" -------------
	var animationID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "animationID", runtime.ParamLocationPath, ctx.Param("animationID"), &animationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter animationID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddAnimationFrame(ctx, bodyID, animationID)
	return err
}

// ListDyanmics converts echo context to params.
func (w *ServerInterfaceWrapper) ListDyanmics(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bodyID" -------------
	var bodyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "bodyID", runtime.ParamLocationPath, ctx.Param("bodyID"), &bodyID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bodyID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListDyanmics(ctx, bodyID)
	return err
}

// AddDynamic converts echo context to params.
func (w *ServerInterfaceWrapper) AddDynamic(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bodyID" -------------
	var bodyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "bodyID", runtime.ParamLocationPath, ctx.Param("bodyID"), &bodyID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bodyID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddDynamic(ctx, bodyID)
	return err
}

// AddDynamicMapping converts echo context to params.
func (w *ServerInterfaceWrapper) AddDynamicMapping(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bodyID" -------------
	var bodyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "bodyID", runtime.ParamLocationPath, ctx.Param("bodyID"), &bodyID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bodyID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddDynamicMapping(ctx, bodyID)
	return err
}

// ListStatics converts echo context to params.
func (w *ServerInterfaceWrapper) ListStatics(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bodyID" -------------
	var bodyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "bodyID", runtime.ParamLocationPath, ctx.Param("bodyID"), &bodyID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bodyID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListStatics(ctx, bodyID)
	return err
}

// AddStatic converts echo context to params.
func (w *ServerInterfaceWrapper) AddStatic(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bodyID" -------------
	var bodyID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "bodyID", runtime.ParamLocationPath, ctx.Param("bodyID"), &bodyID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bodyID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddStatic(ctx, bodyID)
	return err
}

// ListProps converts echo context to params.
func (w *ServerInterfaceWrapper) ListProps(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListProps(ctx)
	return err
}

// AddProp converts echo context to params.
func (w *ServerInterfaceWrapper) AddProp(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddProp(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/body", wrapper.ListBodies)
	router.POST(baseURL+"/body", wrapper.AddBody)
	router.GET(baseURL+"/body/:bodyID/animation", wrapper.ListAnimations)
	router.POST(baseURL+"/body/:bodyID/animation", wrapper.AddAnimation)
	router.POST(baseURL+"/body/:bodyID/animation/:animationID/frame", wrapper.AddAnimationFrame)
	router.GET(baseURL+"/body/:bodyID/dynamic", wrapper.ListDyanmics)
	router.POST(baseURL+"/body/:bodyID/dynamic", wrapper.AddDynamic)
	router.POST(baseURL+"/body/:bodyID/dynamicMapping", wrapper.AddDynamicMapping)
	router.GET(baseURL+"/body/:bodyID/static", wrapper.ListStatics)
	router.POST(baseURL+"/body/:bodyID/static", wrapper.AddStatic)
	router.GET(baseURL+"/prop", wrapper.ListProps)
	router.POST(baseURL+"/prop", wrapper.AddProp)

}
