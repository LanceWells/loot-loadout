// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: characterimage/v1/characterimage.proto

package characterimage

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Coordinates with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Coordinates) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Coordinates with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CoordinatesMultiError, or
// nil if none found.
func (m *Coordinates) ValidateAll() error {
	return m.validate(true)
}

func (m *Coordinates) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetX() >= 32 {
		err := CoordinatesValidationError{
			field:  "X",
			reason: "value must be less than 32",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetY() >= 32 {
		err := CoordinatesValidationError{
			field:  "Y",
			reason: "value must be less than 32",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CoordinatesMultiError(errors)
	}

	return nil
}

// CoordinatesMultiError is an error wrapping multiple validation errors
// returned by Coordinates.ValidateAll() if the designated constraints aren't met.
type CoordinatesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CoordinatesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CoordinatesMultiError) AllErrors() []error { return m }

// CoordinatesValidationError is the validation error returned by
// Coordinates.Validate if the designated constraints aren't met.
type CoordinatesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CoordinatesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CoordinatesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CoordinatesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CoordinatesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CoordinatesValidationError) ErrorName() string { return "CoordinatesValidationError" }

// Error satisfies the builtin error interface
func (e CoordinatesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCoordinates.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CoordinatesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CoordinatesValidationError{}

// Validate checks the field values on Positioning with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Positioning) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Positioning with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PositioningMultiError, or
// nil if none found.
func (m *Positioning) ValidateAll() error {
	return m.validate(true)
}

func (m *Positioning) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetCoordinates() == nil {
		err := PositioningValidationError{
			field:  "Coordinates",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCoordinates()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PositioningValidationError{
					field:  "Coordinates",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PositioningValidationError{
					field:  "Coordinates",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCoordinates()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PositioningValidationError{
				field:  "Coordinates",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetRotation() > 360 {
		err := PositioningValidationError{
			field:  "Rotation",
			reason: "value must be less than or equal to 360",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PositioningMultiError(errors)
	}

	return nil
}

// PositioningMultiError is an error wrapping multiple validation errors
// returned by Positioning.ValidateAll() if the designated constraints aren't met.
type PositioningMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PositioningMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PositioningMultiError) AllErrors() []error { return m }

// PositioningValidationError is the validation error returned by
// Positioning.Validate if the designated constraints aren't met.
type PositioningValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PositioningValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PositioningValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PositioningValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PositioningValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PositioningValidationError) ErrorName() string { return "PositioningValidationError" }

// Error satisfies the builtin error interface
func (e PositioningValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPositioning.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PositioningValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PositioningValidationError{}

// Validate checks the field values on Body with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Body) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Body with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BodyMultiError, or nil if none found.
func (m *Body) ValidateAll() error {
	return m.validate(true)
}

func (m *Body) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDisplayName()) < 1 {
		err := BodyValidationError{
			field:  "DisplayName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return BodyMultiError(errors)
	}

	return nil
}

// BodyMultiError is an error wrapping multiple validation errors returned by
// Body.ValidateAll() if the designated constraints aren't met.
type BodyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BodyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BodyMultiError) AllErrors() []error { return m }

// BodyValidationError is the validation error returned by Body.Validate if the
// designated constraints aren't met.
type BodyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BodyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BodyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BodyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BodyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BodyValidationError) ErrorName() string { return "BodyValidationError" }

// Error satisfies the builtin error interface
func (e BodyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBody.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BodyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BodyValidationError{}

// Validate checks the field values on DynamicMapping with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DynamicMapping) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DynamicMapping with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DynamicMappingMultiError,
// or nil if none found.
func (m *DynamicMapping) ValidateAll() error {
	return m.validate(true)
}

func (m *DynamicMapping) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := DynamicPartType_name[int32(m.GetPart())]; !ok {
		err := DynamicMappingValidationError{
			field:  "Part",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetImage()) > 1024 {
		err := DynamicMappingValidationError{
			field:  "Image",
			reason: "value length must be at most 1024 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DynamicMappingMultiError(errors)
	}

	return nil
}

// DynamicMappingMultiError is an error wrapping multiple validation errors
// returned by DynamicMapping.ValidateAll() if the designated constraints
// aren't met.
type DynamicMappingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DynamicMappingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DynamicMappingMultiError) AllErrors() []error { return m }

// DynamicMappingValidationError is the validation error returned by
// DynamicMapping.Validate if the designated constraints aren't met.
type DynamicMappingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DynamicMappingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DynamicMappingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DynamicMappingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DynamicMappingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DynamicMappingValidationError) ErrorName() string { return "DynamicMappingValidationError" }

// Error satisfies the builtin error interface
func (e DynamicMappingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDynamicMapping.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DynamicMappingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DynamicMappingValidationError{}

// Validate checks the field values on Static with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Static) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Static with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StaticMultiError, or nil if none found.
func (m *Static) ValidateAll() error {
	return m.validate(true)
}

func (m *Static) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDisplayName()) < 1 {
		err := StaticValidationError{
			field:  "DisplayName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := StaticPartType_name[int32(m.GetPart())]; !ok {
		err := StaticValidationError{
			field:  "Part",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetImage()) > 1024 {
		err := StaticValidationError{
			field:  "Image",
			reason: "value length must be at most 1024 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetAnchor() == nil {
		err := StaticValidationError{
			field:  "Anchor",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAnchor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StaticValidationError{
					field:  "Anchor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StaticValidationError{
					field:  "Anchor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAnchor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StaticValidationError{
				field:  "Anchor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StaticMultiError(errors)
	}

	return nil
}

// StaticMultiError is an error wrapping multiple validation errors returned by
// Static.ValidateAll() if the designated constraints aren't met.
type StaticMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StaticMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StaticMultiError) AllErrors() []error { return m }

// StaticValidationError is the validation error returned by Static.Validate if
// the designated constraints aren't met.
type StaticValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StaticValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StaticValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StaticValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StaticValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StaticValidationError) ErrorName() string { return "StaticValidationError" }

// Error satisfies the builtin error interface
func (e StaticValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatic.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StaticValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StaticValidationError{}

// Validate checks the field values on Dynamic with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Dynamic) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Dynamic with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DynamicMultiError, or nil if none found.
func (m *Dynamic) ValidateAll() error {
	return m.validate(true)
}

func (m *Dynamic) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDisplayName()) < 1 {
		err := DynamicValidationError{
			field:  "DisplayName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := DynamicPartType_name[int32(m.GetPart())]; !ok {
		err := DynamicValidationError{
			field:  "Part",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DynamicMultiError(errors)
	}

	return nil
}

// DynamicMultiError is an error wrapping multiple validation errors returned
// by Dynamic.ValidateAll() if the designated constraints aren't met.
type DynamicMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DynamicMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DynamicMultiError) AllErrors() []error { return m }

// DynamicValidationError is the validation error returned by Dynamic.Validate
// if the designated constraints aren't met.
type DynamicValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DynamicValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DynamicValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DynamicValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DynamicValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DynamicValidationError) ErrorName() string { return "DynamicValidationError" }

// Error satisfies the builtin error interface
func (e DynamicValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDynamic.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DynamicValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DynamicValidationError{}

// Validate checks the field values on Frame with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Frame) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Frame with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in FrameMultiError, or nil if none found.
func (m *Frame) ValidateAll() error {
	return m.validate(true)
}

func (m *Frame) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetStaticPositioning()))
		i := 0
		for key := range m.GetStaticPositioning() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetStaticPositioning()[key]
			_ = val

			// no validation rules for StaticPositioning[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, FrameValidationError{
							field:  fmt.Sprintf("StaticPositioning[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, FrameValidationError{
							field:  fmt.Sprintf("StaticPositioning[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return FrameValidationError{
						field:  fmt.Sprintf("StaticPositioning[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if m.GetPropPositioning() == nil {
		err := FrameValidationError{
			field:  "PropPositioning",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPropPositioning()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FrameValidationError{
					field:  "PropPositioning",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FrameValidationError{
					field:  "PropPositioning",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPropPositioning()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FrameValidationError{
				field:  "PropPositioning",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if _, ok := ExpressionType_name[int32(m.GetExpression())]; !ok {
		err := FrameValidationError{
			field:  "Expression",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return FrameMultiError(errors)
	}

	return nil
}

// FrameMultiError is an error wrapping multiple validation errors returned by
// Frame.ValidateAll() if the designated constraints aren't met.
type FrameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FrameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FrameMultiError) AllErrors() []error { return m }

// FrameValidationError is the validation error returned by Frame.Validate if
// the designated constraints aren't met.
type FrameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FrameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FrameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FrameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FrameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FrameValidationError) ErrorName() string { return "FrameValidationError" }

// Error satisfies the builtin error interface
func (e FrameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFrame.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FrameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FrameValidationError{}

// Validate checks the field values on Animation with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Animation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Animation with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AnimationMultiError, or nil
// if none found.
func (m *Animation) ValidateAll() error {
	return m.validate(true)
}

func (m *Animation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDisplayName()) < 1 {
		err := AnimationValidationError{
			field:  "DisplayName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AnimationMultiError(errors)
	}

	return nil
}

// AnimationMultiError is an error wrapping multiple validation errors returned
// by Animation.ValidateAll() if the designated constraints aren't met.
type AnimationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnimationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnimationMultiError) AllErrors() []error { return m }

// AnimationValidationError is the validation error returned by
// Animation.Validate if the designated constraints aren't met.
type AnimationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnimationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnimationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnimationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnimationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnimationValidationError) ErrorName() string { return "AnimationValidationError" }

// Error satisfies the builtin error interface
func (e AnimationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnimation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnimationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnimationValidationError{}

// Validate checks the field values on Prop with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Prop) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Prop with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PropMultiError, or nil if none found.
func (m *Prop) ValidateAll() error {
	return m.validate(true)
}

func (m *Prop) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDisplayName()) < 1 {
		err := PropValidationError{
			field:  "DisplayName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := PropType_name[int32(m.GetProp())]; !ok {
		err := PropValidationError{
			field:  "Prop",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetImage()) > 1024 {
		err := PropValidationError{
			field:  "Image",
			reason: "value length must be at most 1024 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetAnchor() == nil {
		err := PropValidationError{
			field:  "Anchor",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAnchor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PropValidationError{
					field:  "Anchor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PropValidationError{
					field:  "Anchor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAnchor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PropValidationError{
				field:  "Anchor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PropMultiError(errors)
	}

	return nil
}

// PropMultiError is an error wrapping multiple validation errors returned by
// Prop.ValidateAll() if the designated constraints aren't met.
type PropMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PropMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PropMultiError) AllErrors() []error { return m }

// PropValidationError is the validation error returned by Prop.Validate if the
// designated constraints aren't met.
type PropValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PropValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PropValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PropValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PropValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PropValidationError) ErrorName() string { return "PropValidationError" }

// Error satisfies the builtin error interface
func (e PropValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PropValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PropValidationError{}

// Validate checks the field values on AddBodyRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AddBodyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddBodyRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AddBodyRequestMultiError,
// or nil if none found.
func (m *AddBodyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddBodyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetBody() == nil {
		err := AddBodyRequestValidationError{
			field:  "Body",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetBody()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddBodyRequestValidationError{
					field:  "Body",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddBodyRequestValidationError{
					field:  "Body",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBody()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddBodyRequestValidationError{
				field:  "Body",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddBodyRequestMultiError(errors)
	}

	return nil
}

// AddBodyRequestMultiError is an error wrapping multiple validation errors
// returned by AddBodyRequest.ValidateAll() if the designated constraints
// aren't met.
type AddBodyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddBodyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddBodyRequestMultiError) AllErrors() []error { return m }

// AddBodyRequestValidationError is the validation error returned by
// AddBodyRequest.Validate if the designated constraints aren't met.
type AddBodyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddBodyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddBodyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddBodyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddBodyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddBodyRequestValidationError) ErrorName() string { return "AddBodyRequestValidationError" }

// Error satisfies the builtin error interface
func (e AddBodyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddBodyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddBodyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddBodyRequestValidationError{}

// Validate checks the field values on AddBodyResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddBodyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddBodyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddBodyResponseMultiError, or nil if none found.
func (m *AddBodyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddBodyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return AddBodyResponseMultiError(errors)
	}

	return nil
}

// AddBodyResponseMultiError is an error wrapping multiple validation errors
// returned by AddBodyResponse.ValidateAll() if the designated constraints
// aren't met.
type AddBodyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddBodyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddBodyResponseMultiError) AllErrors() []error { return m }

// AddBodyResponseValidationError is the validation error returned by
// AddBodyResponse.Validate if the designated constraints aren't met.
type AddBodyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddBodyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddBodyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddBodyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddBodyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddBodyResponseValidationError) ErrorName() string { return "AddBodyResponseValidationError" }

// Error satisfies the builtin error interface
func (e AddBodyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddBodyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddBodyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddBodyResponseValidationError{}

// Validate checks the field values on ListBodiesRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListBodiesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListBodiesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListBodiesRequestMultiError, or nil if none found.
func (m *ListBodiesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListBodiesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListBodiesRequestMultiError(errors)
	}

	return nil
}

// ListBodiesRequestMultiError is an error wrapping multiple validation errors
// returned by ListBodiesRequest.ValidateAll() if the designated constraints
// aren't met.
type ListBodiesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBodiesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBodiesRequestMultiError) AllErrors() []error { return m }

// ListBodiesRequestValidationError is the validation error returned by
// ListBodiesRequest.Validate if the designated constraints aren't met.
type ListBodiesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBodiesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBodiesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBodiesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBodiesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBodiesRequestValidationError) ErrorName() string {
	return "ListBodiesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListBodiesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBodiesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBodiesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBodiesRequestValidationError{}

// Validate is disabled for ListBodiesResponse. This method will always return nil.
func (m *ListBodiesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll is disabled for ListBodiesResponse. This method will always
// return nil.
func (m *ListBodiesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListBodiesResponse) validate(all bool) error {
	return nil
}

// ListBodiesResponseMultiError is an error wrapping multiple validation errors
// returned by ListBodiesResponse.ValidateAll() if the designated constraints
// aren't met.
type ListBodiesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBodiesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBodiesResponseMultiError) AllErrors() []error { return m }

// ListBodiesResponseValidationError is the validation error returned by
// ListBodiesResponse.Validate if the designated constraints aren't met.
type ListBodiesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBodiesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBodiesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBodiesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBodiesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBodiesResponseValidationError) ErrorName() string {
	return "ListBodiesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListBodiesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBodiesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBodiesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBodiesResponseValidationError{}

// Validate checks the field values on AddDynamicMappingRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddDynamicMappingRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddDynamicMappingRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddDynamicMappingRequestMultiError, or nil if none found.
func (m *AddDynamicMappingRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddDynamicMappingRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetMapping() == nil {
		err := AddDynamicMappingRequestValidationError{
			field:  "Mapping",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMapping()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddDynamicMappingRequestValidationError{
					field:  "Mapping",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddDynamicMappingRequestValidationError{
					field:  "Mapping",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMapping()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddDynamicMappingRequestValidationError{
				field:  "Mapping",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetBodyID()) < 1 {
		err := AddDynamicMappingRequestValidationError{
			field:  "BodyID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AddDynamicMappingRequestMultiError(errors)
	}

	return nil
}

// AddDynamicMappingRequestMultiError is an error wrapping multiple validation
// errors returned by AddDynamicMappingRequest.ValidateAll() if the designated
// constraints aren't met.
type AddDynamicMappingRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddDynamicMappingRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddDynamicMappingRequestMultiError) AllErrors() []error { return m }

// AddDynamicMappingRequestValidationError is the validation error returned by
// AddDynamicMappingRequest.Validate if the designated constraints aren't met.
type AddDynamicMappingRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddDynamicMappingRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddDynamicMappingRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddDynamicMappingRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddDynamicMappingRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddDynamicMappingRequestValidationError) ErrorName() string {
	return "AddDynamicMappingRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AddDynamicMappingRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddDynamicMappingRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddDynamicMappingRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddDynamicMappingRequestValidationError{}

// Validate checks the field values on AddDynamicMappingResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddDynamicMappingResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddDynamicMappingResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddDynamicMappingResponseMultiError, or nil if none found.
func (m *AddDynamicMappingResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddDynamicMappingResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return AddDynamicMappingResponseMultiError(errors)
	}

	return nil
}

// AddDynamicMappingResponseMultiError is an error wrapping multiple validation
// errors returned by AddDynamicMappingResponse.ValidateAll() if the
// designated constraints aren't met.
type AddDynamicMappingResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddDynamicMappingResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddDynamicMappingResponseMultiError) AllErrors() []error { return m }

// AddDynamicMappingResponseValidationError is the validation error returned by
// AddDynamicMappingResponse.Validate if the designated constraints aren't met.
type AddDynamicMappingResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddDynamicMappingResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddDynamicMappingResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddDynamicMappingResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddDynamicMappingResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddDynamicMappingResponseValidationError) ErrorName() string {
	return "AddDynamicMappingResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AddDynamicMappingResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddDynamicMappingResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddDynamicMappingResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddDynamicMappingResponseValidationError{}

// Validate checks the field values on AddStaticRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddStaticRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddStaticRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddStaticRequestMultiError, or nil if none found.
func (m *AddStaticRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddStaticRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetStatic() == nil {
		err := AddStaticRequestValidationError{
			field:  "Static",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetStatic()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddStaticRequestValidationError{
					field:  "Static",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddStaticRequestValidationError{
					field:  "Static",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatic()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddStaticRequestValidationError{
				field:  "Static",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetBodyID()) < 1 {
		err := AddStaticRequestValidationError{
			field:  "BodyID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AddStaticRequestMultiError(errors)
	}

	return nil
}

// AddStaticRequestMultiError is an error wrapping multiple validation errors
// returned by AddStaticRequest.ValidateAll() if the designated constraints
// aren't met.
type AddStaticRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddStaticRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddStaticRequestMultiError) AllErrors() []error { return m }

// AddStaticRequestValidationError is the validation error returned by
// AddStaticRequest.Validate if the designated constraints aren't met.
type AddStaticRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddStaticRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddStaticRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddStaticRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddStaticRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddStaticRequestValidationError) ErrorName() string { return "AddStaticRequestValidationError" }

// Error satisfies the builtin error interface
func (e AddStaticRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddStaticRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddStaticRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddStaticRequestValidationError{}

// Validate checks the field values on AddStaticResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddStaticResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddStaticResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddStaticResponseMultiError, or nil if none found.
func (m *AddStaticResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddStaticResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return AddStaticResponseMultiError(errors)
	}

	return nil
}

// AddStaticResponseMultiError is an error wrapping multiple validation errors
// returned by AddStaticResponse.ValidateAll() if the designated constraints
// aren't met.
type AddStaticResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddStaticResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddStaticResponseMultiError) AllErrors() []error { return m }

// AddStaticResponseValidationError is the validation error returned by
// AddStaticResponse.Validate if the designated constraints aren't met.
type AddStaticResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddStaticResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddStaticResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddStaticResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddStaticResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddStaticResponseValidationError) ErrorName() string {
	return "AddStaticResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AddStaticResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddStaticResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddStaticResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddStaticResponseValidationError{}

// Validate checks the field values on ListStaticRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListStaticRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListStaticRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListStaticRequestMultiError, or nil if none found.
func (m *ListStaticRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListStaticRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListStaticRequestMultiError(errors)
	}

	return nil
}

// ListStaticRequestMultiError is an error wrapping multiple validation errors
// returned by ListStaticRequest.ValidateAll() if the designated constraints
// aren't met.
type ListStaticRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListStaticRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListStaticRequestMultiError) AllErrors() []error { return m }

// ListStaticRequestValidationError is the validation error returned by
// ListStaticRequest.Validate if the designated constraints aren't met.
type ListStaticRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListStaticRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListStaticRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListStaticRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListStaticRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListStaticRequestValidationError) ErrorName() string {
	return "ListStaticRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListStaticRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListStaticRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListStaticRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListStaticRequestValidationError{}

// Validate is disabled for ListStaticsResponse. This method will always return nil.
func (m *ListStaticsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll is disabled for ListStaticsResponse. This method will always
// return nil.
func (m *ListStaticsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListStaticsResponse) validate(all bool) error {
	return nil
}

// ListStaticsResponseMultiError is an error wrapping multiple validation
// errors returned by ListStaticsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListStaticsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListStaticsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListStaticsResponseMultiError) AllErrors() []error { return m }

// ListStaticsResponseValidationError is the validation error returned by
// ListStaticsResponse.Validate if the designated constraints aren't met.
type ListStaticsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListStaticsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListStaticsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListStaticsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListStaticsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListStaticsResponseValidationError) ErrorName() string {
	return "ListStaticsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListStaticsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListStaticsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListStaticsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListStaticsResponseValidationError{}

// Validate checks the field values on AddDynamicRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddDynamicRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddDynamicRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddDynamicRequestMultiError, or nil if none found.
func (m *AddDynamicRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddDynamicRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetDynamic() == nil {
		err := AddDynamicRequestValidationError{
			field:  "Dynamic",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDynamic()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddDynamicRequestValidationError{
					field:  "Dynamic",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddDynamicRequestValidationError{
					field:  "Dynamic",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDynamic()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddDynamicRequestValidationError{
				field:  "Dynamic",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetBodyID()) < 1 {
		err := AddDynamicRequestValidationError{
			field:  "BodyID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetImage()) > 1024 {
		err := AddDynamicRequestValidationError{
			field:  "Image",
			reason: "value length must be at most 1024 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AddDynamicRequestMultiError(errors)
	}

	return nil
}

// AddDynamicRequestMultiError is an error wrapping multiple validation errors
// returned by AddDynamicRequest.ValidateAll() if the designated constraints
// aren't met.
type AddDynamicRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddDynamicRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddDynamicRequestMultiError) AllErrors() []error { return m }

// AddDynamicRequestValidationError is the validation error returned by
// AddDynamicRequest.Validate if the designated constraints aren't met.
type AddDynamicRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddDynamicRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddDynamicRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddDynamicRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddDynamicRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddDynamicRequestValidationError) ErrorName() string {
	return "AddDynamicRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AddDynamicRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddDynamicRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddDynamicRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddDynamicRequestValidationError{}

// Validate checks the field values on AddDynamicResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddDynamicResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddDynamicResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddDynamicResponseMultiError, or nil if none found.
func (m *AddDynamicResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddDynamicResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return AddDynamicResponseMultiError(errors)
	}

	return nil
}

// AddDynamicResponseMultiError is an error wrapping multiple validation errors
// returned by AddDynamicResponse.ValidateAll() if the designated constraints
// aren't met.
type AddDynamicResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddDynamicResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddDynamicResponseMultiError) AllErrors() []error { return m }

// AddDynamicResponseValidationError is the validation error returned by
// AddDynamicResponse.Validate if the designated constraints aren't met.
type AddDynamicResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddDynamicResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddDynamicResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddDynamicResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddDynamicResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddDynamicResponseValidationError) ErrorName() string {
	return "AddDynamicResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AddDynamicResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddDynamicResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddDynamicResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddDynamicResponseValidationError{}

// Validate checks the field values on ListDynamicsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDynamicsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDynamicsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDynamicsRequestMultiError, or nil if none found.
func (m *ListDynamicsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDynamicsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListDynamicsRequestMultiError(errors)
	}

	return nil
}

// ListDynamicsRequestMultiError is an error wrapping multiple validation
// errors returned by ListDynamicsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListDynamicsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDynamicsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDynamicsRequestMultiError) AllErrors() []error { return m }

// ListDynamicsRequestValidationError is the validation error returned by
// ListDynamicsRequest.Validate if the designated constraints aren't met.
type ListDynamicsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDynamicsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDynamicsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDynamicsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDynamicsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDynamicsRequestValidationError) ErrorName() string {
	return "ListDynamicsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListDynamicsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDynamicsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDynamicsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDynamicsRequestValidationError{}

// Validate is disabled for ListDynamicsResponse. This method will always
// return nil.
func (m *ListDynamicsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll is disabled for ListDynamicsResponse. This method will always
// return nil.
func (m *ListDynamicsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDynamicsResponse) validate(all bool) error {
	return nil
}

// ListDynamicsResponseMultiError is an error wrapping multiple validation
// errors returned by ListDynamicsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListDynamicsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDynamicsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDynamicsResponseMultiError) AllErrors() []error { return m }

// ListDynamicsResponseValidationError is the validation error returned by
// ListDynamicsResponse.Validate if the designated constraints aren't met.
type ListDynamicsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDynamicsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDynamicsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDynamicsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDynamicsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDynamicsResponseValidationError) ErrorName() string {
	return "ListDynamicsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListDynamicsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDynamicsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDynamicsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDynamicsResponseValidationError{}

// Validate checks the field values on AddAnimationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddAnimationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddAnimationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddAnimationRequestMultiError, or nil if none found.
func (m *AddAnimationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddAnimationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAnimation() == nil {
		err := AddAnimationRequestValidationError{
			field:  "Animation",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAnimation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddAnimationRequestValidationError{
					field:  "Animation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddAnimationRequestValidationError{
					field:  "Animation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAnimation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddAnimationRequestValidationError{
				field:  "Animation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetBodyID()) < 1 {
		err := AddAnimationRequestValidationError{
			field:  "BodyID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AddAnimationRequestMultiError(errors)
	}

	return nil
}

// AddAnimationRequestMultiError is an error wrapping multiple validation
// errors returned by AddAnimationRequest.ValidateAll() if the designated
// constraints aren't met.
type AddAnimationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddAnimationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddAnimationRequestMultiError) AllErrors() []error { return m }

// AddAnimationRequestValidationError is the validation error returned by
// AddAnimationRequest.Validate if the designated constraints aren't met.
type AddAnimationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddAnimationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddAnimationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddAnimationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddAnimationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddAnimationRequestValidationError) ErrorName() string {
	return "AddAnimationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AddAnimationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddAnimationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddAnimationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddAnimationRequestValidationError{}

// Validate checks the field values on AddAnimationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddAnimationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddAnimationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddAnimationResponseMultiError, or nil if none found.
func (m *AddAnimationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddAnimationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return AddAnimationResponseMultiError(errors)
	}

	return nil
}

// AddAnimationResponseMultiError is an error wrapping multiple validation
// errors returned by AddAnimationResponse.ValidateAll() if the designated
// constraints aren't met.
type AddAnimationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddAnimationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddAnimationResponseMultiError) AllErrors() []error { return m }

// AddAnimationResponseValidationError is the validation error returned by
// AddAnimationResponse.Validate if the designated constraints aren't met.
type AddAnimationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddAnimationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddAnimationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddAnimationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddAnimationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddAnimationResponseValidationError) ErrorName() string {
	return "AddAnimationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AddAnimationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddAnimationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddAnimationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddAnimationResponseValidationError{}

// Validate checks the field values on ListAnimationsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAnimationsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAnimationsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAnimationsRequestMultiError, or nil if none found.
func (m *ListAnimationsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAnimationsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListAnimationsRequestMultiError(errors)
	}

	return nil
}

// ListAnimationsRequestMultiError is an error wrapping multiple validation
// errors returned by ListAnimationsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListAnimationsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAnimationsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAnimationsRequestMultiError) AllErrors() []error { return m }

// ListAnimationsRequestValidationError is the validation error returned by
// ListAnimationsRequest.Validate if the designated constraints aren't met.
type ListAnimationsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAnimationsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAnimationsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAnimationsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAnimationsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAnimationsRequestValidationError) ErrorName() string {
	return "ListAnimationsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListAnimationsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAnimationsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAnimationsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAnimationsRequestValidationError{}

// Validate is disabled for ListAnimationsResponse. This method will always
// return nil.
func (m *ListAnimationsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll is disabled for ListAnimationsResponse. This method will always
// return nil.
func (m *ListAnimationsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAnimationsResponse) validate(all bool) error {
	return nil
}

// ListAnimationsResponseMultiError is an error wrapping multiple validation
// errors returned by ListAnimationsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListAnimationsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAnimationsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAnimationsResponseMultiError) AllErrors() []error { return m }

// ListAnimationsResponseValidationError is the validation error returned by
// ListAnimationsResponse.Validate if the designated constraints aren't met.
type ListAnimationsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAnimationsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAnimationsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAnimationsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAnimationsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAnimationsResponseValidationError) ErrorName() string {
	return "ListAnimationsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListAnimationsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAnimationsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAnimationsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAnimationsResponseValidationError{}

// Validate checks the field values on AddFrameRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddFrameRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddFrameRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddFrameRequestMultiError, or nil if none found.
func (m *AddFrameRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddFrameRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetFrame() == nil {
		err := AddFrameRequestValidationError{
			field:  "Frame",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetFrame()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddFrameRequestValidationError{
					field:  "Frame",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddFrameRequestValidationError{
					field:  "Frame",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFrame()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddFrameRequestValidationError{
				field:  "Frame",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetAnimationID()) < 1 {
		err := AddFrameRequestValidationError{
			field:  "AnimationID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetImage()) > 1024 {
		err := AddFrameRequestValidationError{
			field:  "Image",
			reason: "value length must be at most 1024 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AddFrameRequestMultiError(errors)
	}

	return nil
}

// AddFrameRequestMultiError is an error wrapping multiple validation errors
// returned by AddFrameRequest.ValidateAll() if the designated constraints
// aren't met.
type AddFrameRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddFrameRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddFrameRequestMultiError) AllErrors() []error { return m }

// AddFrameRequestValidationError is the validation error returned by
// AddFrameRequest.Validate if the designated constraints aren't met.
type AddFrameRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddFrameRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddFrameRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddFrameRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddFrameRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddFrameRequestValidationError) ErrorName() string { return "AddFrameRequestValidationError" }

// Error satisfies the builtin error interface
func (e AddFrameRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddFrameRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddFrameRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddFrameRequestValidationError{}

// Validate checks the field values on AddFrameResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddFrameResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddFrameResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddFrameResponseMultiError, or nil if none found.
func (m *AddFrameResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddFrameResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return AddFrameResponseMultiError(errors)
	}

	return nil
}

// AddFrameResponseMultiError is an error wrapping multiple validation errors
// returned by AddFrameResponse.ValidateAll() if the designated constraints
// aren't met.
type AddFrameResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddFrameResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddFrameResponseMultiError) AllErrors() []error { return m }

// AddFrameResponseValidationError is the validation error returned by
// AddFrameResponse.Validate if the designated constraints aren't met.
type AddFrameResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddFrameResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddFrameResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddFrameResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddFrameResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddFrameResponseValidationError) ErrorName() string { return "AddFrameResponseValidationError" }

// Error satisfies the builtin error interface
func (e AddFrameResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddFrameResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddFrameResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddFrameResponseValidationError{}

// Validate checks the field values on AddPropRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AddPropRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddPropRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AddPropRequestMultiError,
// or nil if none found.
func (m *AddPropRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddPropRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetProp() == nil {
		err := AddPropRequestValidationError{
			field:  "Prop",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetProp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddPropRequestValidationError{
					field:  "Prop",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddPropRequestValidationError{
					field:  "Prop",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddPropRequestValidationError{
				field:  "Prop",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddPropRequestMultiError(errors)
	}

	return nil
}

// AddPropRequestMultiError is an error wrapping multiple validation errors
// returned by AddPropRequest.ValidateAll() if the designated constraints
// aren't met.
type AddPropRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddPropRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddPropRequestMultiError) AllErrors() []error { return m }

// AddPropRequestValidationError is the validation error returned by
// AddPropRequest.Validate if the designated constraints aren't met.
type AddPropRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddPropRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddPropRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddPropRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddPropRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddPropRequestValidationError) ErrorName() string { return "AddPropRequestValidationError" }

// Error satisfies the builtin error interface
func (e AddPropRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddPropRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddPropRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddPropRequestValidationError{}

// Validate checks the field values on AddPropResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddPropResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddPropResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddPropResponseMultiError, or nil if none found.
func (m *AddPropResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddPropResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return AddPropResponseMultiError(errors)
	}

	return nil
}

// AddPropResponseMultiError is an error wrapping multiple validation errors
// returned by AddPropResponse.ValidateAll() if the designated constraints
// aren't met.
type AddPropResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddPropResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddPropResponseMultiError) AllErrors() []error { return m }

// AddPropResponseValidationError is the validation error returned by
// AddPropResponse.Validate if the designated constraints aren't met.
type AddPropResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddPropResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddPropResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddPropResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddPropResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddPropResponseValidationError) ErrorName() string { return "AddPropResponseValidationError" }

// Error satisfies the builtin error interface
func (e AddPropResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddPropResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddPropResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddPropResponseValidationError{}

// Validate checks the field values on ListPropsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListPropsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPropsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPropsRequestMultiError, or nil if none found.
func (m *ListPropsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPropsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListPropsRequestMultiError(errors)
	}

	return nil
}

// ListPropsRequestMultiError is an error wrapping multiple validation errors
// returned by ListPropsRequest.ValidateAll() if the designated constraints
// aren't met.
type ListPropsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPropsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPropsRequestMultiError) AllErrors() []error { return m }

// ListPropsRequestValidationError is the validation error returned by
// ListPropsRequest.Validate if the designated constraints aren't met.
type ListPropsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPropsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPropsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPropsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPropsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPropsRequestValidationError) ErrorName() string { return "ListPropsRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListPropsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPropsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPropsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPropsRequestValidationError{}

// Validate is disabled for ListPropsResponse. This method will always return nil.
func (m *ListPropsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll is disabled for ListPropsResponse. This method will always
// return nil.
func (m *ListPropsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPropsResponse) validate(all bool) error {
	return nil
}

// ListPropsResponseMultiError is an error wrapping multiple validation errors
// returned by ListPropsResponse.ValidateAll() if the designated constraints
// aren't met.
type ListPropsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPropsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPropsResponseMultiError) AllErrors() []error { return m }

// ListPropsResponseValidationError is the validation error returned by
// ListPropsResponse.Validate if the designated constraints aren't met.
type ListPropsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPropsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPropsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPropsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPropsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPropsResponseValidationError) ErrorName() string {
	return "ListPropsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListPropsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPropsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPropsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPropsResponseValidationError{}
