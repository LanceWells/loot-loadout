syntax = "proto3";

package lantspants.lootloadout.characterimage;

import "validate/validate.proto";
import "google/api/annotations.proto";

option go_package = "github.com/lantspants/lootloadout/api/characterimage";

// Images provides rpc endpoints used to interact with character images.
service Images {
  // CreateBodyType creates a new base body type. The body type is the basic template for all other
  // character imagery. For example, this method could be used to create a new body type for an
  // equine, effeminite model or for a draconic, male model.
  rpc CreateBodyType(CreateBodyTypeRequest) returns (CreateBodyTypeResponse) {}

  rpc GetBodyType(GetBodyTypeRequest) returns (GetBodyTypeResponse) {}

  rpc CreateDynamicPartMapping(CreateDynamicPartMappingRequest) returns (CreateDynamicPartMappingResponse) {
    option (google.api.http) = {
      post: "/v1/dynamicpartmapping"
      body: "*"
    };
  }

  // CreateStaticPart provides a static image of some body part. These body parts do not move, and
  // are only translated via simple means (rotation at 45degree increments).
  rpc CreateStaticPart(CreateStaticPartRequest) returns (CreateStaticPartResponse) {}

  // CreateDynamicPart creates a new body part for use with a specific body type. This is something
  // like an appendage. These body parts are able to move.
  rpc CreateDynamicPart(CreateDynamicPartRequest) returns (CreateDynamicPartResponse) {}

  // CreateProp creates a new prop for use with any body type. These may be a variety of things not
  // covered by the other categories. These may be items or various accessories. These are included
  // as something for a character to interact with during an animation.
  rpc CreateProp(CreatePropRequest) returns (CreatePropResponse) {}

  // CreateAnimation creates a new animation. Please note that any still poses are animations, just
  // done with a single frame. This is the core of what brings together all the disparate data about
  // what a character should look like.
  rpc CreateAnimation(CreateAnimationRequest) returns (CreateAnimationResponse) {}

  // SaveAnimation sends all of the information required to piece-together an animation to the
  // backend. In response, a complete set of frames will be provided that may be used to render the
  // desired animation on the frontend.
  rpc SaveAnimation(SaveAnimationRequest) returns (SaveAnimationResponse) {}

  // ListAnimations returns a list of all of the available animations for a given body type.
  rpc ListAnimations(ListAnimationsRequest) returns (ListAnimationsResponse) {}

  // ListBodyTypes returns a list of all available body types.
  rpc ListBodyTypes(ListBodyTypesRequest) returns (ListBodyTypesResponse) {}

  // ListStaticParts returns a list of all available static parts of the given type.
  rpc ListStaticParts(ListStaticPartsRequest) returns (ListStaticPartsResponse) {}

  // ListDynamicParts returns a list of all available dynamic parts of the given type.
  rpc ListDynamicParts(ListDynamicPartsRequest) returns (ListStaticPartsResponse) {}

  // ListProps returns a list of all available props of the given type.
  rpc ListProps(ListPropsRequest) returns (ListPropsResponse) {}
}

// Coordinates refers to basic image relational coordinates. These are assumed to be within the
// 32-bit plane.
message Coordinates {
  uint32 x = 1 [(validate.rules).uint32 = {lt: 32}];
  uint32 y = 2 [(validate.rules).uint32 = {lt: 32}];
}

// Positioning describes the position and rotation of a given item.
message Positioning {
  Coordinates coordinates = 1 [(validate.rules).message.required = true];

  // rotation is the circular rotation for a given object. 
  uint32 rotation = 2 [(validate.rules).uint32 = {lte: 360}];
}

// PropType describes the type of prop.
enum PropType {
  WEAPON_MELEE_1H = 0;
  WEAPON_MELEE_2H = 1;
  WEAPON_RANGE_1H = 2;
  WEAPON_RANGE_2H = 3;

  // TODO:
  // MUSICAL_WIND_1H = 5;
  // MUSICAL_WIND_2H = 5;
  // MUSICAL_BRASS_1H = 5;
  // MUSICAL_BRASS_2H = 5;
  // MUSICAL_STRING_1H = 5;
  // MUSICAL_STRING_2H = 5;
  // MUSICAL_PERCUSSION_1H = 5;
  // MUSICAL_PERCUSSION_2H = 5;
}

// StaticPartType describes the type of the part. These are non-transforming, stationary (or x/y
// mobile) parts.
enum StaticPartType {
  BODY = 0;
  HEAD = 1;
  HAIR = 2;
  EYES = 3;
  ACCESSORY_HEAD = 4;
}

// DynamicPartType describes the type of the part. These are moving, transforming parts.
enum DynamicPartType {
  LEFT_LEG = 0;
  RIGHT_LEG = 1;
  LEFT_ARM = 2;
  RIGHT_ARM = 3;
}

// ExpressionType describes the expression for a character. This is defined per-animation-frame.
enum ExpressionType {
  NEUTRAL = 0;
}

// Animation describes the information required to render a given character.
message Animation {
  // Frame describes the animation data for a single frame of animation.
  message Frame {
    // image describes the bytes for the image (this is in .png format).
    bytes image = 1 [(validate.rules).bytes = { max_len: 1024 }];

    // parts describes the positioning of any static parts in the animation.
    //
    // Note: the keys must be able to be evaluated to StaticPartType.
    map<string, Positioning> parts = 2;

    // prop describes the positioning of the prop used with this animation.
    Positioning prop = 3;

    // expression defines the expressive state of the character. This will impact any parts that
    // show expression (e.g. eyes).
    ExpressionType expression = 4 [(validate.rules).enum.defined_only = true];
  }

  // displayName is the name that will be rendered to the user. This is also used for any alt-text.
  string displayName = 1 [(validate.rules).string = { min_len: 1 } ];

  // bodyTypeIdentifier is the id for the body type that this animation should be used with.
  string bodyTypeIdentifier = 2 [(validate.rules).string = { min_len: 1 } ];

  // allowed is the list of types of props that are enabled with this animation.
  repeated PropType allowed = 3;

  // frames is the set of frames used to animate.
  repeated Frame frames = 4;
}

// BodyType describes the type of body that serves as the base template.
message BodyType {
  // displayName is the name that will be rendered to the user. This is also used for any alt-text.
  string displayName = 1 [(validate.rules).string = { min_len: 1 } ];

  // partMaps is a series of images that define the placement and color of any dynamic parts
  // associated with this body. These are our 'lookup' maps. The color of each pixel in each image
  // gives us positional data to refer to the color map created using a CreateDynamicPart request.
  //
  // Note: the keys must be able to be evaluated to DynamicPartType.
  map<string, bytes> partMaps = 2;
}

message DynamicPartMapping {
  string bodyTypeIdentifier = 1[(validate.rules).string = { min_len: 1 }];
  DynamicPartType type = 2 [(validate.rules).enum.defined_only = true];
  bytes image = 3;
}

// StaticPart describes a body part that does not change other than rotation or simple x/y movement.
message StaticPart {
  // displayName is the name that will be rendered to the user. This is also used for any alt-text.
  string displayName = 2 [(validate.rules).string = { min_len: 1 } ];

  // bodyTypeIdentifier is the id for the body type that this animation should be used with.
  string bodyTypeIdentifier = 3 [(validate.rules).string = { min_len: 1 } ];

  // type is the type of the body part that this represents.
  StaticPartType type = 4 [(validate.rules).enum.defined_only = true];
  
  // image describes the bytes for the image (this is in .png format).
  bytes image = 5 [(validate.rules).bytes = { max_len: 256 }];

  // anchor gives us the base x/y position for this part. The Animation type uses this coordinate to
  // determine where to place the related static part in each frame.
  Coordinates anchor = 6 [(validate.rules).message.required = true];
}

// DynamicPart describes a body part that moves or transforms, and can be rendered in a pseudo-3D
// space.
message DynamicPart {
  // displayName is the name that will be rendered to the user. This is also used for any alt-text.
  string displayName = 2 [(validate.rules).string = { min_len: 1 }];

  // bodyTypeIdentifier is the id for the body type that this animation should be used with.
  string bodyTypeIdentifier = 3 [(validate.rules).string = { min_len: 1 } ];

  // type is the type of the body part that this represents.
  DynamicPartType type = 4 [(validate.rules).enum.defined_only = true];
  
  // image describes the bytes for the image (this is in .png format).
  bytes image = 5 [(validate.rules).bytes = { max_len: 256 }];
}

// Prop describes an item that a character will interact with. This is intended to be used heavily
// with any given animation.
message Prop {
  // displayName is the name that will be rendered to the user. This is also used for any alt-text.
  string displayName = 2 [(validate.rules).string = { min_len: 1 }];

  // type describes the type of prop that this represents.
  PropType type = 3 [(validate.rules).enum.defined_only = true];
  
  // image describes the bytes for the image (this is in .png format).
  bytes image = 4 [(validate.rules).bytes = { max_len: 256 }];

  // anchor gives us the base x/y position for this prop. The Animation type uses this coordinate to
  // determine where to place the related prop in each frame.
  Coordinates anchor = 5 [(validate.rules).message.required = true];  
}

message CreateBodyTypeRequest {
  // body is the data required to create a new body.
  BodyType body = 1 [(validate.rules).message.required = true];
}

message CreateBodyTypeResponse {
  // id is the identifier of the newly-created body type.
  string id = 1;
}

message GetBodyTypeRequest {
  string id  = 1;
}

message GetBodyTypeResponse {
  BodyType body = 1;
}

message CreateDynamicPartMappingRequest {
  DynamicPartMapping dynamicPartMapping = 1 [(validate.rules).message.required = true];
}

message CreateDynamicPartMappingResponse {
  string id = 1;
}

message CreateStaticPartRequest {
  // staticPart is the data required to create a new static part.
  StaticPart staticPart = 1 [(validate.rules).message.required = true];
}

message CreateStaticPartResponse {
  // id is the identifier of the newly-created static part.
  string id = 1;
}

message CreateDynamicPartRequest {
  // dynamicPart is the data required to create a new dynamic part.
  DynamicPart dynamicPart = 1 [(validate.rules).message.required = true];
}

message CreateDynamicPartResponse {
  // id is the identifier of the newly-created dynamic part.
  string id = 1;
}

message CreatePropRequest {
  // prop is the data required to create a new prop.
  Prop prop = 1 [(validate.rules).message.required = true];
}

message CreatePropResponse {
  // id is the identifier of the newly-created prop.
  string id = 1;
}

message CreateAnimationRequest {
  // animation is the data required to create a new animation.
  Animation animation = 1;
}

message CreateAnimationResponse {
  // id is the identifier of the newly-created animation.
  string id = 1;
}

message SaveAnimationRequest {
  // animationIdentifier is the ID for the animation that will be used to render the output.
  string animationIdentifier = 1 [(validate.rules).string = { min_len: 1 }];

  // dynamicIdentifiers is a mapping of required dynamic types to their given identifiers.
  //
  // Note: the keys must be able to be evaluated to DynamicPartType.
  map<string, string> dynamicIdentifiers = 2;

  // staticIdentifiers is a mapping of required static types to their given identifiers.
  //
  // Note: the keys must be able to be evaluated to StaticPartType.
  map<string, string> staticIdentifiers = 3;

  // propIdentifier is the ID for a given prop to render within an animation.
  string propIdentifier = 4;
}

message SaveAnimationResponse {
  // id is the identifier of the newly-created animation.
  string id = 1;
}

message ListAnimationsRequest {
  // bodyTypeIdentifier is the ID for the body type to list items for.
  string bodyTypeIdentifier = 1 [(validate.rules).string = { min_len: 1 } ];
}

message ListAnimationsResponse {
  map<string, Animation> animations = 1;
}

message ListBodyTypesRequest {}

message ListBodyTypesResponse {
  map<string, BodyType> types = 1;
}

message ListStaticPartsRequest {
  // bodyTypeIdentifier is the ID for the body type to list items for.
  string bodyTypeIdentifier = 1 [(validate.rules).string = { min_len: 1 } ];

  // types, if provided, filters the results of the items that are returned.
  repeated StaticPartType types = 2;
}

message ListStaticPartsResponse {
  map<string, StaticPart> parts = 1;
}

message ListDynamicPartsRequest {
  // bodyTypeIdentifier is the ID for the body type to list items for.
  string bodyTypeIdentifier = 1 [(validate.rules).string = { min_len: 1 } ];
  
  // types, if provided, filters the results of the items that are returned.
  repeated DynamicPartType types = 2;
}

message ListDynamicPartsResponse {
  map<string, DynamicPart> parts = 1;
}

message ListPropsRequest {
  // types, if provided, filters the results of the items that are returned.
  repeated PropType types = 1;
}

message ListPropsResponse {
  map<string, Prop> props = 1;
}
